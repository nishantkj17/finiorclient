import { EventEmitter, ViewContainerRef, ComponentRef, OnDestroy, ElementRef, OnChanges, OnInit, ComponentFactoryResolver, Renderer2, TemplateRef, SimpleChanges } from '@angular/core';
import { ConfirmationPopoverWindowComponent } from './confirmation-popover-window.component';
import { ConfirmationPopoverOptions } from './confirmation-popover-options.provider';
/**
 * @internal
 */
import * as ɵngcc0 from '@angular/core';
export interface ConfirmCancelEvent {
    clickEvent: MouseEvent;
}
/**
 All properties can be set on the directive as attributes like so (use `ConfirmationPopoverModule.forRoot()` to configure them globally):
 ```html
 <button
   class="btn btn-outline-secondary"
   mwlConfirmationPopover
   [popoverTitle]="popoverTitle"
   [popoverMessage]="popoverMessage"
   placement="left"
   (confirm)="confirmClicked = true"
   (cancel)="cancelClicked = true"
   [(isOpen)]="isOpen">
    Show confirm popover!
  </button>
  ```
 */
export declare class ConfirmationPopoverDirective implements OnDestroy, OnChanges, OnInit {
    private viewContainerRef;
    private elm;
    private defaultOptions;
    private cfr;
    private renderer;
    /**
     * The title of the popover
     */
    popoverTitle: string;
    /**
     * The body text of the popover.
     */
    popoverMessage: string;
    /**
     * The text of the confirm button. Default `Confirm`
     */
    confirmText: string;
    /**
     * The text of the cancel button. Default `Cancel`
     */
    cancelText: string;
    /**
     * The placement of the popover. It can be either `top`, `right`, `bottom` or `left`. Default `top`
     */
    placement: string;
    /**
     * The bootstrap button type of the confirm button. It can be any supported bootstrap color type
     * e.g. `default`, `warning`, `danger` etc. Default `success`
     */
    confirmButtonType: string;
    /**
     * The bootstrap button type of the cancel button. It can be any supported bootstrap color type
     * e.g. `default`, `warning`, `danger` etc. Default `default`
     */
    cancelButtonType: string;
    /**
     * Set to either `confirm` or `cancel` to focus the confirm or cancel button.
     * If omitted, by default it will not focus either button.
     */
    focusButton: string;
    /**
     * Whether to hide the confirm button. Default `false`.
     */
    hideConfirmButton: boolean;
    /**
     * Whether to hide the cancel button. Default `false`.
     */
    hideCancelButton: boolean;
    /**
     * Whether to disable showing the popover. Default `false`.
     */
    isDisabled: boolean;
    /**
     * Will open or show the popover when changed.
     * Can be sugared with `isOpenChange` to emulate 2-way binding like so `[(isOpen)]="isOpen"`
     */
    isOpen: boolean;
    /**
     * A reference to a <ng-template> tag that if set will override the popovers template. Use like so:
     * ```html
     * <ng-template #customTemplate let-options="options">
     *   <div [class]="'popover ' + options.placement" style="display: block">
     *     My custom template
     *   </div>
     * </ng-template>
     * ```
     *
     * Then pass customTemplate to the mwlConfirmationPopover directive like so `[customTemplate]="customTemplate"`
     */
    customTemplate: TemplateRef<any>;
    /**
     * Will emit when the popover is opened or closed
     */
    isOpenChange: EventEmitter<boolean>;
    /**
     * An expression that is called when the confirm button is clicked.
     */
    confirm: EventEmitter<ConfirmCancelEvent>;
    /**
     * An expression that is called when the cancel button is clicked.
     */
    cancel: EventEmitter<ConfirmCancelEvent>;
    /**
     * A custom CSS class to be added to the popover
     */
    popoverClass: string;
    /**
     * Append the element to the document body rather than the trigger element
     */
    appendToBody: boolean;
    /**
     * Swap the order of the confirm and cancel buttons
     */
    reverseButtonOrder: boolean;
    /**
     * Determines whether or not the popover should stay open even when clicking outside of it
     */
    closeOnOutsideClick: boolean;
    /**
     * @internal
     */
    popover: ComponentRef<ConfirmationPopoverWindowComponent>;
    private eventListeners;
    /**
     * @internal
     */
    constructor(viewContainerRef: ViewContainerRef, elm: ElementRef, defaultOptions: ConfirmationPopoverOptions, cfr: ComponentFactoryResolver, renderer: Renderer2);
    /**
     * @internal
     */
    ngOnInit(): void;
    /**
     * @internal
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * @internal
     */
    ngOnDestroy(): void;
    /**
     * @internal
     */
    onConfirm(event: ConfirmCancelEvent): void;
    /**
     * @internal
     */
    onCancel(event: ConfirmCancelEvent): void;
    /**
     * @internal
     */
    togglePopover(): void;
    private onDocumentClick;
    private showPopover;
    private positionPopover;
    private hidePopover;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<ConfirmationPopoverDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<ConfirmationPopoverDirective, "[mwlConfirmationPopover]", never, { "isDisabled": "isDisabled"; "isOpen": "isOpen"; "popoverTitle": "popoverTitle"; "popoverMessage": "popoverMessage"; "confirmText": "confirmText"; "cancelText": "cancelText"; "placement": "placement"; "confirmButtonType": "confirmButtonType"; "cancelButtonType": "cancelButtonType"; "focusButton": "focusButton"; "hideConfirmButton": "hideConfirmButton"; "hideCancelButton": "hideCancelButton"; "customTemplate": "customTemplate"; "popoverClass": "popoverClass"; "appendToBody": "appendToBody"; "reverseButtonOrder": "reverseButtonOrder"; "closeOnOutsideClick": "closeOnOutsideClick"; }, { "isOpenChange": "isOpenChange"; "confirm": "confirm"; "cancel": "cancel"; }, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uZmlybWF0aW9uLXBvcG92ZXIuZGlyZWN0aXZlLmQudHMiLCJzb3VyY2VzIjpbImNvbmZpcm1hdGlvbi1wb3BvdmVyLmRpcmVjdGl2ZS5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgVmlld0NvbnRhaW5lclJlZiwgQ29tcG9uZW50UmVmLCBPbkRlc3Ryb3ksIEVsZW1lbnRSZWYsIE9uQ2hhbmdlcywgT25Jbml0LCBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsIFJlbmRlcmVyMiwgVGVtcGxhdGVSZWYsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dDb21wb25lbnQgfSBmcm9tICcuL2NvbmZpcm1hdGlvbi1wb3BvdmVyLXdpbmRvdy5jb21wb25lbnQnO1xuaW1wb3J0IHsgQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnMgfSBmcm9tICcuL2NvbmZpcm1hdGlvbi1wb3BvdmVyLW9wdGlvbnMucHJvdmlkZXInO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDb25maXJtQ2FuY2VsRXZlbnQge1xuICAgIGNsaWNrRXZlbnQ6IE1vdXNlRXZlbnQ7XG59XG4vKipcbiBBbGwgcHJvcGVydGllcyBjYW4gYmUgc2V0IG9uIHRoZSBkaXJlY3RpdmUgYXMgYXR0cmlidXRlcyBsaWtlIHNvICh1c2UgYENvbmZpcm1hdGlvblBvcG92ZXJNb2R1bGUuZm9yUm9vdCgpYCB0byBjb25maWd1cmUgdGhlbSBnbG9iYWxseSk6XG4gYGBgaHRtbFxuIDxidXR0b25cbiAgIGNsYXNzPVwiYnRuIGJ0bi1vdXRsaW5lLXNlY29uZGFyeVwiXG4gICBtd2xDb25maXJtYXRpb25Qb3BvdmVyXG4gICBbcG9wb3ZlclRpdGxlXT1cInBvcG92ZXJUaXRsZVwiXG4gICBbcG9wb3Zlck1lc3NhZ2VdPVwicG9wb3Zlck1lc3NhZ2VcIlxuICAgcGxhY2VtZW50PVwibGVmdFwiXG4gICAoY29uZmlybSk9XCJjb25maXJtQ2xpY2tlZCA9IHRydWVcIlxuICAgKGNhbmNlbCk9XCJjYW5jZWxDbGlja2VkID0gdHJ1ZVwiXG4gICBbKGlzT3BlbildPVwiaXNPcGVuXCI+XG4gICAgU2hvdyBjb25maXJtIHBvcG92ZXIhXG4gIDwvYnV0dG9uPlxuICBgYGBcbiAqL1xuZXhwb3J0IGRlY2xhcmUgY2xhc3MgQ29uZmlybWF0aW9uUG9wb3ZlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSwgT25DaGFuZ2VzLCBPbkluaXQge1xuICAgIHByaXZhdGUgdmlld0NvbnRhaW5lclJlZjtcbiAgICBwcml2YXRlIGVsbTtcbiAgICBwcml2YXRlIGRlZmF1bHRPcHRpb25zO1xuICAgIHByaXZhdGUgY2ZyO1xuICAgIHByaXZhdGUgcmVuZGVyZXI7XG4gICAgLyoqXG4gICAgICogVGhlIHRpdGxlIG9mIHRoZSBwb3BvdmVyXG4gICAgICovXG4gICAgcG9wb3ZlclRpdGxlOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogVGhlIGJvZHkgdGV4dCBvZiB0aGUgcG9wb3Zlci5cbiAgICAgKi9cbiAgICBwb3BvdmVyTWVzc2FnZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBjb25maXJtIGJ1dHRvbi4gRGVmYXVsdCBgQ29uZmlybWBcbiAgICAgKi9cbiAgICBjb25maXJtVGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSB0ZXh0IG9mIHRoZSBjYW5jZWwgYnV0dG9uLiBEZWZhdWx0IGBDYW5jZWxgXG4gICAgICovXG4gICAgY2FuY2VsVGV4dDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcG92ZXIuIEl0IGNhbiBiZSBlaXRoZXIgYHRvcGAsIGByaWdodGAsIGBib3R0b21gIG9yIGBsZWZ0YC4gRGVmYXVsdCBgdG9wYFxuICAgICAqL1xuICAgIHBsYWNlbWVudDogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBib290c3RyYXAgYnV0dG9uIHR5cGUgb2YgdGhlIGNvbmZpcm0gYnV0dG9uLiBJdCBjYW4gYmUgYW55IHN1cHBvcnRlZCBib290c3RyYXAgY29sb3IgdHlwZVxuICAgICAqIGUuZy4gYGRlZmF1bHRgLCBgd2FybmluZ2AsIGBkYW5nZXJgIGV0Yy4gRGVmYXVsdCBgc3VjY2Vzc2BcbiAgICAgKi9cbiAgICBjb25maXJtQnV0dG9uVHlwZTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFRoZSBib290c3RyYXAgYnV0dG9uIHR5cGUgb2YgdGhlIGNhbmNlbCBidXR0b24uIEl0IGNhbiBiZSBhbnkgc3VwcG9ydGVkIGJvb3RzdHJhcCBjb2xvciB0eXBlXG4gICAgICogZS5nLiBgZGVmYXVsdGAsIGB3YXJuaW5nYCwgYGRhbmdlcmAgZXRjLiBEZWZhdWx0IGBkZWZhdWx0YFxuICAgICAqL1xuICAgIGNhbmNlbEJ1dHRvblR5cGU6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTZXQgdG8gZWl0aGVyIGBjb25maXJtYCBvciBgY2FuY2VsYCB0byBmb2N1cyB0aGUgY29uZmlybSBvciBjYW5jZWwgYnV0dG9uLlxuICAgICAqIElmIG9taXR0ZWQsIGJ5IGRlZmF1bHQgaXQgd2lsbCBub3QgZm9jdXMgZWl0aGVyIGJ1dHRvbi5cbiAgICAgKi9cbiAgICBmb2N1c0J1dHRvbjogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gaGlkZSB0aGUgY29uZmlybSBidXR0b24uIERlZmF1bHQgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBoaWRlQ29uZmlybUJ1dHRvbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRvIGhpZGUgdGhlIGNhbmNlbCBidXR0b24uIERlZmF1bHQgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBoaWRlQ2FuY2VsQnV0dG9uOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdG8gZGlzYWJsZSBzaG93aW5nIHRoZSBwb3BvdmVyLiBEZWZhdWx0IGBmYWxzZWAuXG4gICAgICovXG4gICAgaXNEaXNhYmxlZDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBXaWxsIG9wZW4gb3Igc2hvdyB0aGUgcG9wb3ZlciB3aGVuIGNoYW5nZWQuXG4gICAgICogQ2FuIGJlIHN1Z2FyZWQgd2l0aCBgaXNPcGVuQ2hhbmdlYCB0byBlbXVsYXRlIDItd2F5IGJpbmRpbmcgbGlrZSBzbyBgWyhpc09wZW4pXT1cImlzT3BlblwiYFxuICAgICAqL1xuICAgIGlzT3BlbjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byBhIDxuZy10ZW1wbGF0ZT4gdGFnIHRoYXQgaWYgc2V0IHdpbGwgb3ZlcnJpZGUgdGhlIHBvcG92ZXJzIHRlbXBsYXRlLiBVc2UgbGlrZSBzbzpcbiAgICAgKiBgYGBodG1sXG4gICAgICogPG5nLXRlbXBsYXRlICNjdXN0b21UZW1wbGF0ZSBsZXQtb3B0aW9ucz1cIm9wdGlvbnNcIj5cbiAgICAgKiAgIDxkaXYgW2NsYXNzXT1cIidwb3BvdmVyICcgKyBvcHRpb25zLnBsYWNlbWVudFwiIHN0eWxlPVwiZGlzcGxheTogYmxvY2tcIj5cbiAgICAgKiAgICAgTXkgY3VzdG9tIHRlbXBsYXRlXG4gICAgICogICA8L2Rpdj5cbiAgICAgKiA8L25nLXRlbXBsYXRlPlxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogVGhlbiBwYXNzIGN1c3RvbVRlbXBsYXRlIHRvIHRoZSBtd2xDb25maXJtYXRpb25Qb3BvdmVyIGRpcmVjdGl2ZSBsaWtlIHNvIGBbY3VzdG9tVGVtcGxhdGVdPVwiY3VzdG9tVGVtcGxhdGVcImBcbiAgICAgKi9cbiAgICBjdXN0b21UZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PjtcbiAgICAvKipcbiAgICAgKiBXaWxsIGVtaXQgd2hlbiB0aGUgcG9wb3ZlciBpcyBvcGVuZWQgb3IgY2xvc2VkXG4gICAgICovXG4gICAgaXNPcGVuQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG4gICAgLyoqXG4gICAgICogQW4gZXhwcmVzc2lvbiB0aGF0IGlzIGNhbGxlZCB3aGVuIHRoZSBjb25maXJtIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIGNvbmZpcm06IEV2ZW50RW1pdHRlcjxDb25maXJtQ2FuY2VsRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIEFuIGV4cHJlc3Npb24gdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgY2FuY2VsIGJ1dHRvbiBpcyBjbGlja2VkLlxuICAgICAqL1xuICAgIGNhbmNlbDogRXZlbnRFbWl0dGVyPENvbmZpcm1DYW5jZWxFdmVudD47XG4gICAgLyoqXG4gICAgICogQSBjdXN0b20gQ1NTIGNsYXNzIHRvIGJlIGFkZGVkIHRvIHRoZSBwb3BvdmVyXG4gICAgICovXG4gICAgcG9wb3ZlckNsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQXBwZW5kIHRoZSBlbGVtZW50IHRvIHRoZSBkb2N1bWVudCBib2R5IHJhdGhlciB0aGFuIHRoZSB0cmlnZ2VyIGVsZW1lbnRcbiAgICAgKi9cbiAgICBhcHBlbmRUb0JvZHk6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogU3dhcCB0aGUgb3JkZXIgb2YgdGhlIGNvbmZpcm0gYW5kIGNhbmNlbCBidXR0b25zXG4gICAgICovXG4gICAgcmV2ZXJzZUJ1dHRvbk9yZGVyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIHBvcG92ZXIgc2hvdWxkIHN0YXkgb3BlbiBldmVuIHdoZW4gY2xpY2tpbmcgb3V0c2lkZSBvZiBpdFxuICAgICAqL1xuICAgIGNsb3NlT25PdXRzaWRlQ2xpY2s6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcG9wb3ZlcjogQ29tcG9uZW50UmVmPENvbmZpcm1hdGlvblBvcG92ZXJXaW5kb3dDb21wb25lbnQ+O1xuICAgIHByaXZhdGUgZXZlbnRMaXN0ZW5lcnM7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iodmlld0NvbnRhaW5lclJlZjogVmlld0NvbnRhaW5lclJlZiwgZWxtOiBFbGVtZW50UmVmLCBkZWZhdWx0T3B0aW9uczogQ29uZmlybWF0aW9uUG9wb3Zlck9wdGlvbnMsIGNmcjogQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCByZW5kZXJlcjogUmVuZGVyZXIyKTtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZ09uSW5pdCgpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5nT25EZXN0cm95KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgb25Db25maXJtKGV2ZW50OiBDb25maXJtQ2FuY2VsRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG9uQ2FuY2VsKGV2ZW50OiBDb25maXJtQ2FuY2VsRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRvZ2dsZVBvcG92ZXIoKTogdm9pZDtcbiAgICBwcml2YXRlIG9uRG9jdW1lbnRDbGljaztcbiAgICBwcml2YXRlIHNob3dQb3BvdmVyO1xuICAgIHByaXZhdGUgcG9zaXRpb25Qb3BvdmVyO1xuICAgIHByaXZhdGUgaGlkZVBvcG92ZXI7XG59XG4iXX0=